" helpline.vim
"
" http://code.arp242.net/helpline.vim
"
" See the bottom of this file for copyright & license information.

scriptencoding utf-8
if exists('g:loaded_helpline') | finish | endif
let g:loaded_line = 1
let s:save_cpo = &cpo
set cpo&vim


"let s:shortcuts = {
"	\ 'branch_name': 'new helpline#branch_name()',
"\}

let s:autocmd_shortcuts = {
	\ 'new': 'BufNewFile,BufReadPost,BufEnter',
\}


" Process the &statusline variable. This should always be invoked after the
" &statusline changes.
fun helpline#process()
	call s:tokenize_statusline()
	call s:helpline('all')
endfun

" Helper to define a new colour.
fun! helpline#define_color(name, props)
	execute 'highlight Helpline_' . a:name . ' ' . a:props
	augroup __helpline_autogenerated__
		autocmd ColorScheme * execute 'highlight Helpline_' . a:name . ' ' . a:props
	augroup end
endfun


fun! s:tokenize_statusline() abort
	let s:original_statusline = &statusline

	" The format of this is:
	" [
	"   " Raw text, we can just echo this
	"   {
	"     type: 'raw',
	"     content: '%<%f %h%m%r',
	"   },
	"
	"   " A command to run
	"   {
	"     type: 'run',
	"     content: '${InsertEnter system("date +%%H:%%m:%%S")[:-2]}'
	"     autocmd: ['InsertEnter']
	"     cmd: 'system("date +%%H:%%m:%%S")[:-2]',
	"     last: '',
	"   },
	"
	"   " A color to process
	"   {
	"     type: 'color',
	"     name: 'grey',
	"     nr: 3,
	"     colored: '${new system('git rev-parse --abbrev-ref HEAD')}',
	"     content: '%{grey ${new system('git rev-parse --abbrev-ref HEAD')}}',
	"   },
	" ]

	" Expand shortcuts
	let l:statusline = &statusline
	"for [l:k, l:v] in items(s:shortcuts)
	"	let l:statusline = substitute(l:statusline, '$' . l:k, l:v, 'g')
	"endfor
	for [l:k, l:v] in items(s:autocmd_shortcuts)
		let l:statusline = substitute(l:statusline, '${' . l:k . ' ', '${' . l:v . ' ', 'g')
	endfor

	" Now scan for our patterns and process them
	let s:tokenized = []
	let l:seen_autocmds = []

	" TODO: Doesn't work for nested:
	"
	"   ['${foo ad}', '$', 'foo', 'ad', '', '', '', '', '', '']
	"   ['@{grey ${foo ad}', '@', 'grey', '${foo ad', '', '', '', '', '', '']
	"
	" This is because [^}]
	"
	" We should do it from right-to-left for inside out I think?
	let l:pat  = '\v'             " 'very magic'
	let l:pat .= '([\$@])'        " $ or @
	let l:pat .= '\{'             " Open {
	let l:pat .= '([^ ]{-})'      " First word (autocmd or colour)
	let l:pat .= ' ([^}]{-})'     " The content
	let l:pat .= '\}'             " Closing } 

	while 1
		let l:match = match(l:statusline, l:pat)

		" No more matches
		if l:match == -1
			let s:tokenized += s:raw(l:statusline)
			break
		endif

		" Consume everything before the pattern as raw
		if l:match != 0
			let s:tokenized += s:raw(l:statusline[:l:match-1])
			let l:statusline = l:statusline[l:match :]
		endif

		" And consume the match
		let l:l = matchlist(l:statusline, l:pat)
		if l:l[1] == '$'
			let s:tokenized += s:run(l:l[0], l:l[2], l:l[3])
			let l:seen_autocmds += s:tokenized[-1:][0]['autocmd']
		else
			let s:tokenized += s:color(l:l[0], l:l[2], l:l[3])
		endif

		let l:statusline = l:statusline[matchend(l:statusline, l:pat):]
	endwhile

	" Hook into the autocmds we've encountered
	" TODO: Better error on unknown autocmds
	augroup __helpline_autogenerated__
		autocmd!
		call sort(l:seen_autocmds)
		for l:cmd in uniq(l:seen_autocmds)
			execute 'autocmd ' . l:cmd . ' * :call s:helpline("' . l:cmd . '")'
		endfor
	augroup end
endfun


fun s:raw(text) abort
	return [{'type': 'raw', 'content': a:text}]
endfun


fun s:run(text, autocmd, cmd) abort
	return [{
		\ 'type': 'run',
		\ 'content': a:text,
		\ 'autocmd': split(a:autocmd, ','),
		\ 'cmd': a:cmd,
		\ 'last': '',
	\}]
endfun

	
fun s:color(text, name, colored) abort
	return [{
		\ 'type': 'color',
		\ 'content': a:text,
		\ 'name': a:name,
		\ 'colored': a:colored,
		\ 'nr': '1',
	\}]
endfun


fun! s:helpline(autocmd) abort
	if !exists('s:tokenized') | call s:tokenize_statusline() | endif

	let l:pos = winsaveview()
	let l:statusline = ''
	let l:i = 0
	let s:autocmd = a:autocmd

	try
		for l:token in s:tokenized
			if l:token['type'] == 'raw'
				"echom 'r -> ' . l:token['content']
				let l:statusline .= l:token['content']
			elseif l:token['type']  == 'run'
				if a:autocmd == 'all' || index(l:token['autocmd'], a:autocmd) > -1
					"echom 'c -> ' . l:token['cmd'] . '  =>  ' .  eval(l:token['cmd'])
					let l:e = eval(l:token['cmd'])
					"let l:e = eval('system("date +%H:%m:%S")[:-2]')
					let s:tokenized[l:i]['last'] = l:e
					let l:statusline .= l:e
				else
					let l:statusline .= l:token['last']
				endif
			elseif l:token['type']  == 'color'
				"echom 'color -> '
				" TODO
			endif

			let l:i += 1
		endfor
	finally
		call winrestview(l:pos)
	endtry

	let &stl = l:statusline
endfun


" Kick it off
call helpline#process()

let &cpo = s:save_cpo
unlet s:save_cpo


" The MIT License (MIT)
"
" Copyright Â© 2015-2016 Martin Tournoij
"
" Permission is hereby granted, free of charge, to any person obtaining a copy
" of this software and associated documentation files (the "Software"), to
" deal in the Software without restriction, including without limitation the
" rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
" sell copies of the Software, and to permit persons to whom the Software is
" furnished to do so, subject to the following conditions:
"
" The above copyright notice and this permission notice shall be included in
" all copies or substantial portions of the Software.
"
" The software is provided "as is", without warranty of any kind, express or
" implied, including but not limited to the warranties of merchantability,
" fitness for a particular purpose and noninfringement. In no event shall the
" authors or copyright holders be liable for any claim, damages or other
" liability, whether in an action of contract, tort or otherwise, arising
" from, out of or in connection with the software or the use or other dealings
" in the software.
