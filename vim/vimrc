set encoding=utf-8
scriptencoding utf-8

"set packpath^=~/.cache/vim             " Use ~/.cache so we can easy copy ~/.vim without loads of stuff.
syntax on                              " Switch syntax highlighting on.
filetype plugin indent on              " Enable filetype detection.
set termguicolors                      " Use true colors.
let &t_8f = "\<Esc>[38;2;%lu;%lu;%lum" " Set correct escape codes to make termguicolors
let &t_8b = "\<Esc>[48;2;%lu;%lu;%lum" " work in st.

silent! colorscheme default2           " Load my color scheme if it exists.
if get(g:, 'colors_name', '') isnot# 'default2'
    colorscheme default                " Fall back to default (some Linuxes overwrite this in global vimrc).
endif

set background=light                   " Make sure correct value is used.
set backspace=indent,eol,start         " Allow backspacing over everything.
set history=500                        " Keep 500 lines of command line history.
set incsearch                          " Jump to match while typing the pattern in /.
set hlsearch                           " Highlight the last used search pattern.
set ignorecase                         " Case-insensitive searching unless \C is in the pattern...
set smartcase                          " ...or the pattern contains an upper-case letter.
set nowrapscan                         " Don't wrap search.
set gdefault                           " Always use the /g flag with :s; add /g to restore the default behaviour.
set textwidth=80                       " Wrap at at 80 characters.
set linebreak                          " Wrap at word.
set showbreak=↪                        " Display at the start of line for wrapped lines.
set breakindent                        " When wrapping show next line on the same indent level.
set breakindentopt=sbr                 " Display showbreak before indent.
set autoindent                         " Copy indent from current line when starting a new line.
set backup                             " Keep backup file when writing.
set backupext=.bak                     " Extension for backup files
set backupskip=/tmp/*                  " No backup for these files.
set listchars=tab:!·,trail:·           " String to use in 'list' mode.
set spelllang=en_gb                    " Default language for spell check.
set helplang=en                        " Always use English in help...
set langmenu=en                        " ...and UI.
set scrolloff=5                        " Minimum number of lines to keep above/below cursor.
set wildmenu                           " Better tab completion at the command-line.
set wildmode=longest,list,full         " Complete longest match, list other matches and select those with wildmenu.
set wildignore=*.o,*.pyc,*.png,*.jpg   " Ignore these files in completion.
set wildignorecase                     " Case is ignored when completing file names and directories.
set completeopt=longest,menuone        " Insert mode completion
                                       " longest: only insert longest common text instead of full match.
                                       " menuone: always show menu, even when there is 1 match.
set previewheight=6                    " Height of preview window.
set pumheight=10                       " Don't make completion menu too high.
set infercase                          " Like smartcase for insert completion.
set tabpagemax=500                     " Max. number of tabs to be open with -p argument or :tab all "
set showcmd                            " Show partial command in the last line of the screen.
set formatoptions+=j                   " Remove comment character when joining lines with J.
set nojoinspaces                       " Don't add two spaces after interpunction when using J.
set shiftround                         " Round indent to multiple of shiftwidth when using < and >
set smarttab                           " Backspace at start of line remove shiftwidith worth of space.
set matchpairs+=<:>                    " Also match < & > with %.
set switchbuf=useopen,usetab,newtab    " Use open tab (if any) when trying to jump to a quickfix error.
set noexpandtab                        " Real men use real tabs...
set tabstop=4                          " ...which are always 4 spaces wide.
set shiftwidth=0                       " Use tabstop.
set softtabstop=-1                     " Use shiftwidth.
set synmaxcol=500                      " Maximum column in which to search for syntax items.
set t_ti= t_te=                        " Prevent clearing the terminal on exit.
set mouse=                             " I don't want no stinkin' mouse (off by default in Vim, but enabled in Neovim).
set nrformats=bin,hex                  " Don't increment octal numbers.
set paragraphs=                        " Don't include nroff stuff.
set tildeop                            " Use ~ as an operator to switch case.
set clipboard=                         " Never automatically interface with system clipboard.
set nofoldenable                       " Disable folds by default.
set laststatus=2                       " Always show statusline...
set showtabline=2                      " ...and tab bar.
set title                              " Update term title...
set titleold=                          " ...but restore old title after exiting.
set shortmess-=S                       " Show match count on n.
" https://www.reddit.com/r/vim/comments/cn20tv/tip_histogrambased_diffs_using_modern_vim/
"set diffopt=filler,internal,algorithm:histogram,indent-heuristic
set display=lastline,uhex              " lastline  Show as much of the last line as possible instead of @.
                                       " uhex      Always show unprintable chars as <xx> instead of ^C.
set updatecount=50                     " Write to swap file every 50 characters; swap file is also written if nothing
                                       " happens for 4 seconds (as set by the 'updatetime' setting).
set formatoptions+=ncroql              " n   Recognize numbered lists when formatting (see formatlistpat)
                                       " c   Wrap comments with textwidth
                                       " r   Insert comment char after enter
                                       " o   Insert comment char after o/O
                                       " q   Format comments with gq
                                       " l   Do not break lines when they were longer than 'textwidth' to start with
set statusline=
let &statusline .= '%<%f'              " Filename, truncate right
let &statusline .= ' %h%m%r'           " [Help] [modified] [read-only]
let &statusline .= '%{len(getqflist()) > 0 ? "[QE]" : ""}'
let &statusline .= '%{len(getloclist(0)) > 0 ? "[LE]" : ""}'
let &statusline .= '%='                " Right-align from here on.
let &statusline .= ' %{get(v:completed_item, "abbr", "")}'
let &statusline .= ' [line %l of %L]'  " current line, total lines.
let &statusline .= ' [col %v]'         " column.
let &statusline .= ' [0x%B]'           " Byte value under cursor.

if $SSH_CLIENT . $SSH2_CLIENT . $SSH_CONNECTION is# ''
    set ttyfast                        " Assume the terminal is fast for smoother redrawing.
endif

if !has('nvim')    " nvim has different file formant. Only use it for testing so whatever.
    set viminfo='50,<0,n~/.cache/vim/viminfo " '50  save fewer marks.
                                           " <0   prevent saving registers.
endif

" Set/create directory to keep backup, swap, undo files.
set backupdir=$HOME/.cache/vim/backup | call mkdir(&backupdir, 'p', 0700)
set directory=$HOME/.cache/vim/swap   | call mkdir(&directory, 'p', 0700)
set viewdir=$HOME/.cache/vim/view     | call mkdir(&viewdir, 'p', 0700)
set undodir=$HOME/.cache/vim/undo     | call mkdir(&undodir, 'p', 0700)

" Highlight columns 80/120
fun! s:color()
    hi SoftWrap  cterm=underline gui=underline
    hi HardWrap  ctermbg=225     guibg=lightred
    hi SpellRare ctermbg=green   guibg=green      
endfun
call s:color()
augroup softwrap
    au!
    au Colorscheme * call s:color()

    " I don't know why this needs to be in this autocmd, but sometimes it won't
    " work if it's not.
    au BufReadPost,BufNew *
        \  call matchadd('SoftWrap', '\%82v')
        \| call matchadd('HardWrap', '\%122v')
augroup end


if has('gui_running')
	" Don't iconfy on <C-z>
	noremap <C-z> <NOP>

	set mousemodel=popup_setpos            " Use pop-up menu for right button.
	set selectmode=key,mouse               " Also use the mouse for selection.
	set clipboard=unnamedplus              " Default clipboard is system clipboard.
	set guicursor+=a:blinkon0              " Don't blink the cursor
	set guioptions=aiM                     " Remove all the GUI cruft and make gVim look and behave like Vim
										" a: copy-on-select
										" i: Use icon
										" M: No menu

	if has('gui_gtk')                      " Set font
		set guifont=Dejavu\ Sans\ Mono\ 16

		" TODO: make it look the same as terminal, which has:
		"static char *font = "DejaVu Sans Mono:pixelsize=22:antialias=true:autohint=true";
	elseif has('gui_win32')
		set guifont=Dejavu_Sans_Mono:h10
	endif
endif

""" Autocmds
""""""""""""
augroup my-autocmds
    au!

    " Go to the last cursor location when a file is opened, unless this is a git
    " commit (in which case it's annoying).
    au BufReadPost *
        \ if line("'\"") > 1 && line("'\"") <= line("$") && &filetype != 'gitcommit'
            \| exe 'normal! g`"'
        \| endif

    " Don't spellcheck urls.
    au BufReadPost * syn match UrlNoSpell '\w\+:\/\/[^[:space:]]\+' contains=@NoSpell

    " Don't need the syntax highlighting for git commits; don't like it at all.
    au FileType gitcommit
        \  setl syntax=OFF ts=8
        \| syn match gitcommitComment "^#.*"

    " Reset some settings that these ftplugins or syntax files reset :-/
    au FileType python setl ts=4
    au FileType sass   setl noexpandtab sw=4

    " Remove Python 2 keywords.
    au Syntax python
        \ syn keyword pythonTwoBuiltin basestring cmp execfile file long unichr
        \     raw_input reduce reload unicode xrange apply buffer coerce intern

    " 2 spaces is almost universal.
    au FileType yaml setl expandtab ts=2

    " C files are almost always ts=8, and very often mix tabs and spaces.
    au FileType c,cpp setl ts=8

    " Set tabstop for Makefile, config files, etc.
    au BufNewFile,BufRead [Mm]akefile*,crontab*,*rc,*.conf,*.ini,*.cfg,*.rc setl ts=8

    " Set larger textwidth for HTML.
    au FileType html,htmldjango,eruby,haml setl textwidth=100

    " Spaces work better, and don't round indenting by shiftwidth (mucks up
    " marking stuff as code).
    au FileType markdown setl expandtab noshiftround

    " Italics don't work well in tmux; shows black background. Loads of people
    " with the issue, but can't get it to work, so just disable it :-(
    au FileType markdown,html,gohtml,htmldjango,xhtml
                \  if $TMUX isnot ''
                \|   hi htmlItalic cterm=underline
                \| endif

    " Don't need errors; too many false positives.
    au FileType markdown hi markdownError ctermbg=NONE

    " Set textwidth to 76 for emails.
    au BufReadPost /tmp/mail-* setl ft=mail | normal! 0Go
    au BufNewFile,BufReadPost /home/martin/.claws-mail/tmp/tmpmsg.* setl ft=mail
    au FileType mail setl textwidth=76

    " These emails are usually DOS formatted (as should be, per RFC).
    au BufReadPost *.eml setl fileformats+=dos fileformat=dos | edit!

    " Make editing SSH authorized_keys and known_hosts less painful.
    au BufReadPost authorized_keys,known_hosts
        \ setl nowrap noautoindent nosmartindent textwidth=0 formatoptions=

    " Works better most of the time.
    au FileType json,xml setl nowrap

    " Show formatting characters only in insert mode and load vimhelplint.
    au FileType help
                \| if &modifiable
                \|   setl colorcolumn=78
                \|   silent! packadd! vim-vimhelplint
                \|   augroup help_insert
                \|     au InsertEnter <buffer> setl conceallevel=0 | highlight clear Ignore
                \|     au InsertLeave <buffer> setl conceallevel=2
                \|   augroup end
                \| endif

    " Very common in CSS; not sure why this isn't there by default? Hmm.
    au FileType css setl isk+=-

    " Varnish
    autocmd BufRead,BufNewFile *.vcl setfiletype vcl.conf

    " Get MDN help for current element; works for CSS and HTML.
    " TODO: check out:
    "   https://github.com/stephenmckinney/vim-dochub
    "   https://github.com/romainl/vim-devdocs
    au FileType css,html,gohtml,htmldjango,xhtml
                \  setl keywordprg=:MDN
                \| command! -nargs=1 MDN call system(printf(
                \          'firefox https://developer.mozilla.org/en-US/docs/Web/%s/%s',
                \          (&ft is# 'css' ? 'CSS' : 'HTML/Element'), <f-args>))
augroup end



""" Commands
""""""""""""

" Get the syntax name of character under the cursor
command! SyntaxName :echo synIDattr(synID(line('.'), col('.'), 1), 'name')

" Clean trailing whitespace.
fun! s:trim_whitespace()
    let l:save = winsaveview()
    keeppattern %s/\s\+$//e
    call winrestview(l:save)
endfun
command! TrimWhitespace call s:trim_whitespace()

" Move a file and update buffer.
fun! s:mv(dest)
    let l:src = expand('%:p')
	let l:dest = expand(a:dest isnot# '' 
				\ ? a:dest 
				\ : input('New file name: ', expand('%:p'), 'file'))

    if !isdirectory(fnamemodify(l:dest, ':h'))
        call mkdir(fnamemodify(l:dest, ':h'), 'p')
    endif
    if rename(l:src, l:dest) is# 0
        execute 'edit ' . l:dest
    endif
endfun
command! -nargs=? -complete=file Mv call s:mv(<q-args>)

" Call uni on current character.
command! UnicodeName echo
         \ system('uni -q i', 
         \      [strcharpart(strpart(getline('.'), col('.') - 1), 0, 1)]
         \ )[:-2]


""" Keys
""""""""

" Reload config.
nnoremap <Leader>r :source $MYVIMRC<CR>

" Some useful-ish toggles.
nnoremap <F9>  :set shiftround!<CR>:set shiftround?<CR>
nnoremap <F10> :set list!<CR>:set list?<CR>
inoremap <F10> <C-o>:set list!<CR>
nnoremap <F11> :set cursorcolumn!<CR>:set cursorcolumn?<CR>
inoremap <F11> <C-o>:set cursorcolumn!<CR>
nnoremap <F12> :set cursorline!<CR>:set cursorline?<CR>
inoremap <F12> <C-o>:set cursorline!<CR>

" Enable spell check, switch languages
nnoremap <F8>      :set spell!<CR>:set spell?<CR>
inoremap <F8>      <C-o>:set spell!<CR>
nnoremap <Leader>ss :set spell!<CR>:set spell?<CR>
nnoremap <Leader>sn :set spelllang=nl<CR>
nnoremap <Leader>se :set spelllang=en_gb<CR>
nnoremap <Leader>su :set spelllang=en_us<CR>
nnoremap <Leader>sd :set spelllang=de_de<CR>

" Use <C-l> to clear some highlighting, and make sure it works from insert mode.
nnoremap <silent> <C-l> :nohlsearch<CR>:setl nolist nospell<CR>:diffupdate<CR>:syntax sync fromstart<CR><C-l>
inoremap <C-l> <C-o>:exe "normal \<C-l>"<CR>

" We don't need no stinkin' ex mode; use it for formatting.
noremap Q gq

" Bloody annoying.
nnoremap q: :q

" Interface with system clipboard.
noremap <Leader>y "*y
noremap <Leader>p "*p
noremap <Leader>Y "+y
noremap <Leader>P "+p

" Indent in visual and select mode automatically re-selects.
vnoremap > >gv
vnoremap < <gv

" Make n always search forward, even when started with ?
nnoremap <expr> n 'Nn'[v:searchforward]
nnoremap <expr> N 'nN'[v:searchforward]

" Don't move cursor on * and #
nnoremap <silent> * :let @/ = '\<' . expand('<cword>') .  '\>' \| :set hlsearch<CR>
nnoremap <silent> # :let @/ = '\<' . expand('<cword>') .  '\>' \| :set hlsearch<CR>

" Use visual movement rather than line movement.
nnoremap k gk
nnoremap j gj
nnoremap <Up>   gk
nnoremap <Down> gj
inoremap <expr> <Up>   pumvisible() ? "\<Up>"    : "\<C-o>gk"
inoremap <expr> <Down> pumvisible() ? "\<Down>"  : "\<C-o>gj"

" gf and gF opens in a tab.
nnoremap gf <C-w>gf
vnoremap gf <C-w>gf
nnoremap gF <C-w>gF
vnoremap gF <C-w>gF

" Suspend also works from insert.
inoremap <C-z> <C-o><C-z>

" Home works like 0 if already at start of a line, and ^ otherwise.
" Adapted from: http://vim.wikia.com/wiki/VimTip315
noremap <expr> <Home> col('.') is# match(getline('.'), '\S') + 1 ? '0' : '^'
imap <silent> <Home> <C-O><Home>

" Add guesstimate of reading time to g<C-g>.
fun! s:readtime()
    let l:status = v:statusmsg
    try
        exe "silent normal! g\<C-g>"
        echo printf('%s; About %.0f minutes',
                    \ v:statusmsg, ceil(wordcount()['words'] / 200.0))
    finally
        let v:statusmsg = l:status
    endtry
endfun
nnoremap g<C-g> :call <SID>readtime()<CR>

" Use a reasonable completion.
fun! s:guessType()
    if &spell && spellbadword()[1] isnot# ''
        " TODO: Show original word somewhere.
        " TODO: Make completion start even if word is after badly spelled word.
        return "\<C-x>s"
    elseif &completefunc isnot# ''
        return "\<C-x>\<C-u>"
    elseif &omnifunc isnot# ''
        return "\<C-x>\<C-o>"
    elseif exists('*completor#do')                      " https://github.com/maralla/completor.vim
        return "\<C-R>=completor#do('complete')\<CR>"
    elseif exists(':ALEComplete')                       " https://github.com/w0rp/ale
        return "\<C-\>\<C-O>:ALEComplete\<CR>"
	elseif exists('*coc#refresh')                       " https://github.com/neoclide/coc.nvim
		return "\<C-r>=coc#refresh()\<CR>"
    else
        return "\<C-x>\<C-n>"
    endif
endfun
inoremap <expr> <C-@> pumvisible() ? "\<C-n>"  : <SID>guessType()
nnoremap <expr> <C-@> pumvisible() ? "i\<C-n>" : 'i' . <SID>guessType()

" Don't hijack the entire screen for spell checking, just show the top 9 results
" in the commandline.
" Press 0 for the full list. Any key press that's not a valid option (1-9) will
" behave as normal.
fun! s:quickspell()
	if &spell is 0
        echohl Error | echo "Spell checking not enabled" | echohl None
		return
	endif

    " Separator between items.
    let l:sep = ' | '

    " Show as many columns as will fit in the window.
	let l:sug = spellsuggest(expand('<cWORD>'), 9)
    let l:c = 0
    for l:i in range(0, len(l:sug))
        let l:c += len(l:sug[l:i - 1]) + len(printf('%d ', l:i + 1))
        " The -5 is needed to prevent some hit-enter prompts, even when there is
        " enough space (bug?)
        if l:c + (len(l:sep) * l:i) >= &columns - 5
            break
        endif
    endfor

    " Show options; make it stand out a bit.
    echohl QuickFixLine
	echo join(map(l:sug[:l:i - 1], {i, v -> printf('%d %s', l:i+1, l:v)}), l:sep)
    echohl None

    " Get answer.
	let l:char = nr2char(getchar())

    " Display regular spell screen on 0.
    if l:char is# '0'
        normal! z=
        return
    endif

	let l:n = str2nr(l:char)

    " Feed the character if it's not a number, so it's easier to do e.g. "ciW".
    if l:n is 0 || l:n > len(l:sug)
        return feedkeys(l:char)
    endif

    " Replace!
    exe printf("normal! ciW%s\<Esc>", l:sug[l:n-1])
    echo
endfun
nnoremap z= :call <SID>quickspell()<CR>

" Yank without clobbering registers.
nnoremap dD "_dd

" Replace the current line with the unnamed register.
nnoremap RR "_ddP

" Shortcut to write and run :make.
nnoremap MM :silent! :wa<CR>:make<CR>

" Shortcut to close all windows except the current one.
nnoremap <silent> OO :silent wincmd o<CR>

" Format the current line from insert mode.
inoremap <C-f> <C-o>gqk

" I often mistype this :-/
cabbr Set set
cabbr Help help
cabbr tane tabe
cabbr ta tabe
iabbr teh the
iabbr hte the
iabbr Teh The
iabbr seperated separated
iabbr taht that

" Makes stuff a bit easier to type.
iabbr 1= !=

" Kind of specific to Go, but doesn't harm to keep as global abbrs.
iabbr ;= :=
iabbr err1= err !=
iabbr err!= err !=

" Make these common shortcuts work in the commandline.
cnoremap <C-a> <Home>
"cnoremap <C-k>  TODO

" Easier way to close quickfix.
nnoremap <silent> <C-w>q     :cclose\|:lclose<CR>
nnoremap <silent> <C-w><C-q> :cclose\|:lclose<CR>

" Split line.
" TODO: undo should restore cursor position.
" https://github.com/drzel/vim-split-line
nnoremap S :keeppatterns substitute/\s*\%#\s*/\r/e <bar> normal! ==<CR>

""" Plugins
"""""""""""

" Default plugins
"""""""""""""""""
let g:loaded_2html_plugin = 1          " Disable some of the default plugins that I don't use.
let g:loaded_LogiPat = 1
let g:loaded_getscript = 1
let g:loaded_getscriptPlugin = 1
let g:loaded_gzip = 1
let g:loaded_man = 1
let g:loaded_netrw = 1
let g:loaded_netrwFileHandlers = 1
let g:loaded_netrwPlugin = 1
let g:loaded_netrwSettings = 1
let g:loaded_rrhelper = 1
let g:loaded_tarPlugin = 1
let g:loaded_tutor_mode_plugin = 1
let g:loaded_vimball = 1
let g:loaded_vimballPlugin = 1
let g:loaded_zipPlugin = 1
let g:did_install_default_menus = 1    " We don't use the menus (this is comparatively slow)


""" switchy.vim
"""""""""""""""
nnoremap <Leader>a :call switchy#switch('tabedit', 'sbuf')<CR>

""" vim-dirvish
"""""""""""""""
let g:dirvish_relative_paths = 1       " Make paths in the Dirvish buffer relative to getcwd().

augroup my-dirvish
    au!
    au Filetype dirvish
                "\ Remap as I often use q to close the Vim pager.
                \  silent! nunmap <buffer> q
                \| nmap <buffer> Q <Plug>(dirvish_quit)
                "\ Add tab mappings
                \| nnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
                \| xnoremap <buffer> t :call dirvish#open('tabedit', 0)<CR>
                "\ Launch shell in cwd
                \| nnoremap <buffer> <C-t> :lcd %<CR>:silent exec '!' . (has('gui_running') ? 'st -e ' : '') . $SHELL<CR>:lcd<CR><C-l>
augroup end


""" gopher.vim
""""""""""""""
let g:gopher_debug = ['commands']
let g:gopher_highlight = ['string-spell', 'string-fmt', 'fold-import', 'fold-pkg-comment']

augroup my-gopher
    au!

    " Make, lint, and test code.
    au FileType go nnoremap MM :silent! :wa<CR>:compiler go<CR>:silent make!<CR>:redraw!<CR>
    au FileType go nnoremap TT :silent! :wa<CR>:compiler gotest<CR>:silent make!<CR>:redraw!<CR>

    " Format buffer on write.
    au BufWritePre *.go
                \  let s:save = winsaveview()
                \| exe 'keepjumps %!goimports 2>/dev/null || cat /dev/stdin'
                \| call winrestview(s:save)

    autocmd BufReadPre /home/martin/code/goatcounter/*.go
                \ let g:gopher_install_package = 'zgo.at/goatcounter/cmd/goatcounter'
augroup end


""" vim-qf
""""""""""
let g:qf_auto_open_quickfix = 1        " Automatically open qfix and loclist.
let g:qf_auto_open_loclist = 1

" Go to next/prev error; need to use escape codes as <C-Arrow> isn't reliable.
nmap <C-Left>    <Plug>(qf_qf_previous)
nmap <Esc>[D >   <Plug>(qf_qf_previous)
nmap <Esc>[1;5D  <Plug>(qf_qf_previous)
nmap <C-Right>   <Plug>(qf_qf_next)
nmap <Esc>[C     <Plug>(qf_qf_next)
nmap <Esc>[1;5C  <Plug>(qf_qf_next)

" Toggle location list.
nmap <C-Up>      <Plug>(qf_qf_toggle_stay)
nmap <Esc>[A     <Plug>(qf_qf_toggle_stay)
nmap <Esc>[1;5A  <Plug>(qf_qf_toggle_stay)

" TODO: Make <C-Down> switch above mappings to loclist.
" nnoremap <C-Down>
" nnoremap <Esc>[B
" nnoremap <Esc>[1;5B


""" vim-lsc
"""""""""""
" https://github.com/castwide/solargraph
" https://github.com/redhat-developer/yaml-language-server
let g:lsc_server_commands = {
            \ 'go': #{command: 'gopls serve', log_level: -1},
            \ }

"\ https://github.com/mads-hartmann/bash-language-server
" \ 'sh':     #{command: 'bash-language-server start'},
" "\ https://github.com/palantir/python-language-server
" "\ 'python': #{command: 'pyls'},
" "\ https://github.com/vscode-langservers/vscode-css-languageserver-bin
" \ 'css':    #{command: 'css-languageserver --stdio'},
" "\ https://clang.llvm.org/extra/clangd/
" \ 'c':      #{command: 'clangd -log=error'},
" "\ https://github.com/sourcegraph/javascript-typescript-langserver
" \ 'javascript': #{command: 'javascript-typescript-stdio'},
" \ }

let g:lsc_enable_autocomplete = v:false      " Don't complete when typing.
let g:lsc_enable_diagnostics = v:false       " Don't lint code.
let g:lsc_reference_highlights = v:false     " Don't highlight references.
"let g:lsc_enable_incremental_sync = v:false  " Don't constantly send diffs to server.
let g:lsc_preview_split_direction = 'below'  " Show preview at bottom, rather than top.

"let g:lsc_auto_map = {'defaults': v:true, 'SignatureHelp': '<C-k>', 'GoToDefinitionSplit': ''}
let g:lsc_auto_map = {'defaults': v:true, 'GoToDefinitionSplit': ''}
augroup my-lsc
    au!
    au BufNewFile,BufReadPost *
        \  if has_key(get(g:, 'lsc_servers_by_filetype', {}), &filetype) && lsc#server#filetypeActive(&filetype)
        "\     Show function signature in insert mode too (I don't use digraphs).
        "\ \|     inoremap <buffer> <C-k> <C-o>:LSClientSignatureHelp<CR>
        "\     Open in tab, rather than split.
        \|     nnoremap <buffer> <C-w>]     :tab LSClientGoToDefinitionSplit<CR>
        \|     nnoremap <buffer> <C-w><C-]> :tab LSClientGoToDefinitionSplit<CR>
        \|     nnoremap <buffer> gd         :tab LSClientGoToDefinitionSplit<CR>
        \| endif

    " Resize to be as small as possible.
    au WinLeave __lsc_preview__ exe 'resize ' . min([&previewheight, line('$')])
    au User LSCShowPreview      exe 'resize ' . min([&previewheight, line('$')])
augroup end
